"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sqsHandler = exports.SQSMessageHandler = void 0;
const common_1 = require("@nestjs/common");
const logger = new common_1.Logger('SQSHandler');
class SQSMessageHandler {
    static getInstance() {
        if (!SQSMessageHandler.instance) {
            SQSMessageHandler.instance = new SQSMessageHandler();
        }
        return SQSMessageHandler.instance;
    }
    async processSQSEvent(event, context) {
        logger.log(`Processing ${event.Records.length} SQS messages`);
        const results = [];
        for (const record of event.Records) {
            try {
                const result = await this.processRecord(record);
                results.push(result);
                if (result.success) {
                    logger.log(`Message ${result.messageId} processed successfully`);
                }
                else {
                    logger.error(`Message ${result.messageId} failed: ${result.error}`);
                }
            }
            catch (error) {
                logger.error(`Error processing record ${record.messageId}:`, error);
                results.push({
                    success: false,
                    messageId: record.messageId,
                    processedAt: new Date().toISOString(),
                    error: error instanceof Error ? error.message : String(error),
                    retryable: true
                });
            }
        }
        // Log summary
        const successCount = results.filter(r => r.success).length;
        const failureCount = results.length - successCount;
        logger.log(`SQS processing complete: ${successCount} success, ${failureCount} failures`);
        // If any message failed and is retryable, throw error to trigger retry
        const retryableFailures = results.filter(r => !r.success && r.retryable);
        if (retryableFailures.length > 0) {
            throw new Error(`${retryableFailures.length} messages failed and are retryable`);
        }
    }
    async processRecord(record) {
        const messageId = record.messageId;
        const processedAt = new Date().toISOString();
        try {
            // Parse message body
            const message = JSON.parse(record.body);
            logger.log(`Processing message ${messageId} of type ${message.type}`);
            // Validate message structure
            this.validateMessage(message);
            // Route message based on type
            const result = await this.routeMessage(message);
            return {
                success: true,
                messageId,
                processedAt,
                ...result
            };
        }
        catch (error) {
            logger.error(`Failed to process message ${messageId}:`, error);
            return {
                success: false,
                messageId,
                processedAt,
                error: error instanceof Error ? error.message : String(error),
                retryable: this.isRetryableError(error)
            };
        }
    }
    validateMessage(message) {
        if (!message.id || !message.type || !message.payload || !message.timestamp) {
            throw new Error('Invalid message structure: missing required fields');
        }
        // Validate timestamp format
        if (isNaN(Date.parse(message.timestamp))) {
            throw new Error('Invalid timestamp format');
        }
        // Validate message type
        const validTypes = ['sample.create', 'sample.update', 'sample.delete', 'notification.send', 'audit.log'];
        if (!validTypes.includes(message.type)) {
            throw new Error(`Invalid message type: ${message.type}`);
        }
    }
    async routeMessage(message) {
        switch (message.type) {
            case 'sample.create':
                return await this.handleSampleCreate(message);
            case 'sample.update':
                return await this.handleSampleUpdate(message);
            case 'sample.delete':
                return await this.handleSampleDelete(message);
            case 'notification.send':
                return await this.handleNotificationSend(message);
            default:
                throw new Error(`Unknown message type: ${message.type}`);
        }
    }
    async handleSampleCreate(message) {
        logger.log(`Handling sample creation: ${JSON.stringify(message.payload)}`);
        // Here you would integrate with your NestJS services
        // For now, we'll simulate processing
        await this.simulateProcessing();
        return { success: true };
    }
    async handleSampleUpdate(message) {
        logger.log(`Handling sample update: ${JSON.stringify(message.payload)}`);
        await this.simulateProcessing();
        return { success: true };
    }
    async handleSampleDelete(message) {
        logger.log(`Handling sample deletion: ${JSON.stringify(message.payload)}`);
        await this.simulateProcessing();
        return { success: true };
    }
    async handleNotificationSend(message) {
        logger.log(`Handling notification: ${JSON.stringify(message.payload)}`);
        await this.simulateProcessing();
        return { success: true };
    }
    async simulateProcessing() {
        // Simulate some processing time
        await new Promise(resolve => setTimeout(resolve, 100));
    }
    isRetryableError(error) {
        // Define which errors should trigger retry
        const retryableErrors = [
            'ECONNREFUSED',
            'ETIMEDOUT',
            'ENOTFOUND',
            'Database connection failed',
            'Service temporarily unavailable'
        ];
        const errorMessage = error.message?.toLowerCase() || '';
        return retryableErrors.some(retryableError => errorMessage.includes(retryableError.toLowerCase()));
    }
}
exports.SQSMessageHandler = SQSMessageHandler;
// Export handler function for Lambda
const sqsHandler = async (event, context) => {
    const handler = SQSMessageHandler.getInstance();
    return handler.processSQSEvent(event, context);
};
exports.sqsHandler = sqsHandler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3FzLmhhbmRsZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzcXMuaGFuZGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSwyQ0FBd0M7QUFHeEMsTUFBTSxNQUFNLEdBQUcsSUFBSSxlQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7QUFFeEMsTUFBYSxpQkFBaUI7SUFHNUIsTUFBTSxDQUFDLFdBQVc7UUFDaEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQ2hDLGlCQUFpQixDQUFDLFFBQVEsR0FBRyxJQUFJLGlCQUFpQixFQUFFLENBQUM7UUFDdkQsQ0FBQztRQUNELE9BQU8saUJBQWlCLENBQUMsUUFBUSxDQUFDO0lBQ3BDLENBQUM7SUFFRCxLQUFLLENBQUMsZUFBZSxDQUFDLEtBQWUsRUFBRSxPQUFnQjtRQUNyRCxNQUFNLENBQUMsR0FBRyxDQUFDLGNBQWMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLGVBQWUsQ0FBQyxDQUFDO1FBRTlELE1BQU0sT0FBTyxHQUEwQixFQUFFLENBQUM7UUFFMUMsS0FBSyxNQUFNLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDbkMsSUFBSSxDQUFDO2dCQUNILE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDaEQsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFFckIsSUFBSSxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUM7b0JBQ25CLE1BQU0sQ0FBQyxHQUFHLENBQUMsV0FBVyxNQUFNLENBQUMsU0FBUyx5QkFBeUIsQ0FBQyxDQUFDO2dCQUNuRSxDQUFDO3FCQUFNLENBQUM7b0JBQ04sTUFBTSxDQUFDLEtBQUssQ0FBQyxXQUFXLE1BQU0sQ0FBQyxTQUFTLFlBQVksTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Z0JBQ3RFLENBQUM7WUFDSCxDQUFDO1lB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QixnQ0FBZ0M7UUFDaEMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRU8sZ0JBQWdCLENBQUMsS0FBVTtRQUNqQywyQ0FBMkM7UUFDM0MsTUFBTSxlQUFlLEdBQUc7WUFDdEIsY0FBYztZQUNkLFdBQVc7WUFDWCxXQUFXO1lBQ1gsNEJBQTRCO1lBQzVCLGlDQUFpQztTQUNsQyxDQUFDO1FBRUYsTUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFLENBQUM7UUFDeEQsT0FBTyxlQUFlLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQzNDLFlBQVksQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQ3BELENBQUM7SUFDSixDQUFDO0NBQ0Y7QUEzS0QsOENBMktDO0FBRUQscUNBQXFDO0FBQzlCLE1BQU0sVUFBVSxHQUFHLEtBQUssRUFBRSxLQUFlLEVBQUUsT0FBZ0IsRUFBaUIsRUFBRTtJQUNuRixNQUFNLE9BQU8sR0FBRyxpQkFBaUIsQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUNoRCxPQUFPLE9BQU8sQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQ2pELENBQUMsQ0FBQztBQUhXLFFBQUEsVUFBVSxjQUdyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNRU0V2ZW50LCBTUVNSZWNvcmQsIENvbnRleHQgfSBmcm9tICdhd3MtbGFtYmRhJztcclxuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnQG5lc3Rqcy9jb21tb24nO1xyXG5pbXBvcnQgeyBTUVNNZXNzYWdlLCBTUVNQcm9jZXNzaW5nUmVzdWx0LCBUeXBlZFNRU01lc3NhZ2UgfSBmcm9tICcuLi9pbnRlcmZhY2VzL3Nxcy1tZXNzYWdlLmludGVyZmFjZSc7XHJcblxyXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdTUVNIYW5kbGVyJyk7XHJcblxyXG5leHBvcnQgY2xhc3MgU1FTTWVzc2FnZUhhbmRsZXIge1xyXG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOiBTUVNNZXNzYWdlSGFuZGxlcjtcclxuXHJcbiAgc3RhdGljIGdldEluc3RhbmNlKCk6IFNRU01lc3NhZ2VIYW5kbGVyIHtcclxuICAgIGlmICghU1FTTWVzc2FnZUhhbmRsZXIuaW5zdGFuY2UpIHtcclxuICAgICAgU1FTTWVzc2FnZUhhbmRsZXIuaW5zdGFuY2UgPSBuZXcgU1FTTWVzc2FnZUhhbmRsZXIoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBTUVNNZXNzYWdlSGFuZGxlci5pbnN0YW5jZTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHByb2Nlc3NTUVNFdmVudChldmVudDogU1FTRXZlbnQsIGNvbnRleHQ6IENvbnRleHQpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIGxvZ2dlci5sb2coYFByb2Nlc3NpbmcgJHtldmVudC5SZWNvcmRzLmxlbmd0aH0gU1FTIG1lc3NhZ2VzYCk7XHJcblxyXG4gICAgY29uc3QgcmVzdWx0czogU1FTUHJvY2Vzc2luZ1Jlc3VsdFtdID0gW107XHJcblxyXG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgZXZlbnQuUmVjb3Jkcykge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJvY2Vzc1JlY29yZChyZWNvcmQpO1xyXG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xyXG4gICAgICAgICAgbG9nZ2VyLmxvZyhgTWVzc2FnZSAke3Jlc3VsdC5tZXNzYWdlSWR9IHByb2Nlc3NlZCBzdWNjZXNzZnVsbHlgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgbG9nZ2VyLmVycm9yKGBNZXNzYWdlICR7cmVzdWx0Lm1lc3NhZ2VJZH0gZmFpbGVkOiAke3Jlc3VsdC5lcnJvcn1gKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgbG9nZ2VyLmVycm9yKGBFcnJvciBwcm9jZXNzaW5nIHJlY29yZCAke3JlY29yZC5tZXNzYWdlSWR9OmAsIGVycm9yKTtcclxuICAgICAgICByZXN1bHRzLnB1c2goe1xyXG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXHJcbiAgICAgICAgICBtZXNzYWdlSWQ6IHJlY29yZC5tZXNzYWdlSWQsXHJcbiAgICAgICAgICBwcm9jZXNzZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgZXJyb3I6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKSxcclxuICAgICAgICAgIHJldHJ5YWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTG9nIHN1bW1hcnlcclxuICAgIGNvbnN0IHN1Y2Nlc3NDb3VudCA9IHJlc3VsdHMuZmlsdGVyKHIgPT4gci5zdWNjZXNzKS5sZW5ndGg7XHJcbiAgICBjb25zdCBmYWlsdXJlQ291bnQgPSByZXN1bHRzLmxlbmd0aCAtIHN1Y2Nlc3NDb3VudDtcclxuICAgIFxyXG4gICAgbG9nZ2VyLmxvZyhgU1FTIHByb2Nlc3NpbmcgY29tcGxldGU6ICR7c3VjY2Vzc0NvdW50fSBzdWNjZXNzLCAke2ZhaWx1cmVDb3VudH0gZmFpbHVyZXNgKTtcclxuXHJcbiAgICAvLyBJZiBhbnkgbWVzc2FnZSBmYWlsZWQgYW5kIGlzIHJldHJ5YWJsZSwgdGhyb3cgZXJyb3IgdG8gdHJpZ2dlciByZXRyeVxyXG4gICAgY29uc3QgcmV0cnlhYmxlRmFpbHVyZXMgPSByZXN1bHRzLmZpbHRlcihyID0+ICFyLnN1Y2Nlc3MgJiYgci5yZXRyeWFibGUpO1xyXG4gICAgaWYgKHJldHJ5YWJsZUZhaWx1cmVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3JldHJ5YWJsZUZhaWx1cmVzLmxlbmd0aH0gbWVzc2FnZXMgZmFpbGVkIGFuZCBhcmUgcmV0cnlhYmxlYCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHByb2Nlc3NSZWNvcmQocmVjb3JkOiBTUVNSZWNvcmQpOiBQcm9taXNlPFNRU1Byb2Nlc3NpbmdSZXN1bHQ+IHtcclxuICAgIGNvbnN0IG1lc3NhZ2VJZCA9IHJlY29yZC5tZXNzYWdlSWQ7XHJcbiAgICBjb25zdCBwcm9jZXNzZWRBdCA9IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBQYXJzZSBtZXNzYWdlIGJvZHlcclxuICAgICAgY29uc3QgbWVzc2FnZTogU1FTTWVzc2FnZSA9IEpTT04ucGFyc2UocmVjb3JkLmJvZHkpO1xyXG4gICAgICBcclxuICAgICAgbG9nZ2VyLmxvZyhgUHJvY2Vzc2luZyBtZXNzYWdlICR7bWVzc2FnZUlkfSBvZiB0eXBlICR7bWVzc2FnZS50eXBlfWApO1xyXG5cclxuICAgICAgLy8gVmFsaWRhdGUgbWVzc2FnZSBzdHJ1Y3R1cmVcclxuICAgICAgdGhpcy52YWxpZGF0ZU1lc3NhZ2UobWVzc2FnZSk7XHJcblxyXG4gICAgICAvLyBSb3V0ZSBtZXNzYWdlIGJhc2VkIG9uIHR5cGVcclxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5yb3V0ZU1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXHJcbiAgICAgICAgbWVzc2FnZUlkLFxyXG4gICAgICAgIHByb2Nlc3NlZEF0LFxyXG4gICAgICAgIC4uLnJlc3VsdFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgbG9nZ2VyLmVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyBtZXNzYWdlICR7bWVzc2FnZUlkfTpgLCBlcnJvcik7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxyXG4gICAgICAgIG1lc3NhZ2VJZCxcclxuICAgICAgICBwcm9jZXNzZWRBdCxcclxuICAgICAgICBlcnJvcjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpLFxyXG4gICAgICAgIHJldHJ5YWJsZTogdGhpcy5pc1JldHJ5YWJsZUVycm9yKGVycm9yKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSB2YWxpZGF0ZU1lc3NhZ2UobWVzc2FnZTogU1FTTWVzc2FnZSk6IHZvaWQge1xyXG4gICAgaWYgKCFtZXNzYWdlLmlkIHx8ICFtZXNzYWdlLnR5cGUgfHwgIW1lc3NhZ2UucGF5bG9hZCB8fCAhbWVzc2FnZS50aW1lc3RhbXApIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lc3NhZ2Ugc3RydWN0dXJlOiBtaXNzaW5nIHJlcXVpcmVkIGZpZWxkcycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFZhbGlkYXRlIHRpbWVzdGFtcCBmb3JtYXRcclxuICAgIGlmIChpc05hTihEYXRlLnBhcnNlKG1lc3NhZ2UudGltZXN0YW1wKSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRpbWVzdGFtcCBmb3JtYXQnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBWYWxpZGF0ZSBtZXNzYWdlIHR5cGVcclxuICAgIGNvbnN0IHZhbGlkVHlwZXMgPSBbJ3NhbXBsZS5jcmVhdGUnLCAnc2FtcGxlLnVwZGF0ZScsICdzYW1wbGUuZGVsZXRlJywgJ25vdGlmaWNhdGlvbi5zZW5kJywgJ2F1ZGl0LmxvZyddO1xyXG4gICAgaWYgKCF2YWxpZFR5cGVzLmluY2x1ZGVzKG1lc3NhZ2UudHlwZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgdHlwZTogJHttZXNzYWdlLnR5cGV9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHJvdXRlTWVzc2FnZShtZXNzYWdlOiBTUVNNZXNzYWdlKTogUHJvbWlzZTxQYXJ0aWFsPFNRU1Byb2Nlc3NpbmdSZXN1bHQ+PiB7XHJcbiAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xyXG4gICAgICBjYXNlICdzYW1wbGUuY3JlYXRlJzpcclxuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5oYW5kbGVTYW1wbGVDcmVhdGUobWVzc2FnZSk7XHJcbiAgICAgIGNhc2UgJ3NhbXBsZS51cGRhdGUnOlxyXG4gICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZVNhbXBsZVVwZGF0ZShtZXNzYWdlKTtcclxuICAgICAgY2FzZSAnc2FtcGxlLmRlbGV0ZSc6XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlU2FtcGxlRGVsZXRlKG1lc3NhZ2UpO1xyXG4gICAgICBjYXNlICdub3RpZmljYXRpb24uc2VuZCc6XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlTm90aWZpY2F0aW9uU2VuZChtZXNzYWdlKTtcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbWVzc2FnZSB0eXBlOiAke21lc3NhZ2UudHlwZX1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlU2FtcGxlQ3JlYXRlKG1lc3NhZ2U6IFNRU01lc3NhZ2UpOiBQcm9taXNlPFBhcnRpYWw8U1FTUHJvY2Vzc2luZ1Jlc3VsdD4+IHtcclxuICAgIGxvZ2dlci5sb2coYEhhbmRsaW5nIHNhbXBsZSBjcmVhdGlvbjogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLnBheWxvYWQpfWApO1xyXG4gICAgXHJcbiAgICAvLyBIZXJlIHlvdSB3b3VsZCBpbnRlZ3JhdGUgd2l0aCB5b3VyIE5lc3RKUyBzZXJ2aWNlc1xyXG4gICAgLy8gRm9yIG5vdywgd2UnbGwgc2ltdWxhdGUgcHJvY2Vzc2luZ1xyXG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZVByb2Nlc3NpbmcoKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVTYW1wbGVVcGRhdGUobWVzc2FnZTogU1FTTWVzc2FnZSk6IFByb21pc2U8UGFydGlhbDxTUVNQcm9jZXNzaW5nUmVzdWx0Pj4ge1xyXG4gICAgbG9nZ2VyLmxvZyhgSGFuZGxpbmcgc2FtcGxlIHVwZGF0ZTogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLnBheWxvYWQpfWApO1xyXG4gICAgXHJcbiAgICBhd2FpdCB0aGlzLnNpbXVsYXRlUHJvY2Vzc2luZygpO1xyXG4gICAgXHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGhhbmRsZVNhbXBsZURlbGV0ZShtZXNzYWdlOiBTUVNNZXNzYWdlKTogUHJvbWlzZTxQYXJ0aWFsPFNRU1Byb2Nlc3NpbmdSZXN1bHQ+PiB7XHJcbiAgICBsb2dnZXIubG9nKGBIYW5kbGluZyBzYW1wbGUgZGVsZXRpb246ICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZS5wYXlsb2FkKX1gKTtcclxuICAgIFxyXG4gICAgYXdhaXQgdGhpcy5zaW11bGF0ZVByb2Nlc3NpbmcoKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVOb3RpZmljYXRpb25TZW5kKG1lc3NhZ2U6IFNRU01lc3NhZ2UpOiBQcm9taXNlPFBhcnRpYWw8U1FTUHJvY2Vzc2luZ1Jlc3VsdD4+IHtcclxuICAgIGxvZ2dlci5sb2coYEhhbmRsaW5nIG5vdGlmaWNhdGlvbjogJHtKU09OLnN0cmluZ2lmeShtZXNzYWdlLnBheWxvYWQpfWApO1xyXG4gICAgXHJcbiAgICBhd2FpdCB0aGlzLnNpbXVsYXRlUHJvY2Vzc2luZygpO1xyXG4gICAgXHJcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHNpbXVsYXRlUHJvY2Vzc2luZygpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIC8vIFNpbXVsYXRlIHNvbWUgcHJvY2Vzc2luZyB0aW1lXHJcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGlzUmV0cnlhYmxlRXJyb3IoZXJyb3I6IGFueSk6IGJvb2xlYW4ge1xyXG4gICAgLy8gRGVmaW5lIHdoaWNoIGVycm9ycyBzaG91bGQgdHJpZ2dlciByZXRyeVxyXG4gICAgY29uc3QgcmV0cnlhYmxlRXJyb3JzID0gW1xyXG4gICAgICAnRUNPTk5SRUZVU0VEJyxcclxuICAgICAgJ0VUSU1FRE9VVCcsXHJcbiAgICAgICdFTk9URk9VTkQnLFxyXG4gICAgICAnRGF0YWJhc2UgY29ubmVjdGlvbiBmYWlsZWQnLFxyXG4gICAgICAnU2VydmljZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZSdcclxuICAgIF07XHJcblxyXG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IubWVzc2FnZT8udG9Mb3dlckNhc2UoKSB8fCAnJztcclxuICAgIHJldHVybiByZXRyeWFibGVFcnJvcnMuc29tZShyZXRyeWFibGVFcnJvciA9PiBcclxuICAgICAgZXJyb3JNZXNzYWdlLmluY2x1ZGVzKHJldHJ5YWJsZUVycm9yLnRvTG93ZXJDYXNlKCkpXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG5cclxuLy8gRXhwb3J0IGhhbmRsZXIgZnVuY3Rpb24gZm9yIExhbWJkYVxyXG5leHBvcnQgY29uc3Qgc3FzSGFuZGxlciA9IGFzeW5jIChldmVudDogU1FTRXZlbnQsIGNvbnRleHQ6IENvbnRleHQpOiBQcm9taXNlPHZvaWQ+ID0+IHtcclxuICBjb25zdCBoYW5kbGVyID0gU1FTTWVzc2FnZUhhbmRsZXIuZ2V0SW5zdGFuY2UoKTtcclxuICByZXR1cm4gaGFuZGxlci5wcm9jZXNzU1FTRXZlbnQoZXZlbnQsIGNvbnRleHQpO1xyXG59O1xyXG4iXX0=